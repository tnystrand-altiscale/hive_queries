+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DAT DUMP FOR: container_time_series_alloc_and_run_extend.sql
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===================================================================

===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		number_apps                 bigint,
		host                        string,
		container_start_time        bigint,
        container_run_time          bigint,
		container_minute_start_time bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_vhacked_with_unagg
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime as container_start_time,
    cf.allocatedtime as container_run_time,
	floor(cf.requestedtime/60000)*60 as container_minute_start_time,
	if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		cts.container_wait_time,
		cts.container_wait_time
		+floor(cf.requestedtime/1000)
		-cts.minute_start
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Sat Sep  5 01:01:33 UTC 2015
-------------------------------------------------------------------


===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		number_apps                 bigint,
		host                        string,
		container_start_time        bigint,
        container_run_time          bigint,
		container_minute_start_time bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime as container_start_time,
    cf.allocatedtime as container_run_time,
	floor(cf.requestedtime/60000)*60 as container_minute_start_time,
	if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		cts.container_wait_time,
		cts.container_wait_time
		+floor(cf.requestedtime/1000)
		-cts.minute_start
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Sat Sep  5 01:14:21 UTC 2015
-------------------------------------------------------------------


===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		number_apps                 bigint,
		host                        string,
		container_start_time        bigint,
        container_run_time          bigint,
		container_minute_start_time bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime as container_start_time,
    cf.allocatedtime as container_run_time,
	floor(cf.requestedtime/60000)*60 as container_minute_start_time,
	if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		cts.container_wait_time,
		cts.container_wait_time
		+floor(cf.requestedtime/1000)
		-cts.minute_start
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Sat Sep  5 01:15:43 UTC 2015
-------------------------------------------------------------------

cts.container_wait_time	cts.memory	cts.cluster_memory	cts.minute_start	cts.job_id	cts.queue	cts.container_id	cts.state	cts.measure_date	cts.account	cts.cluster_uuid	cts.principal_uuid	cts.user_key	vcores	cts.number_apps	cts.host	container_start_time	container_run_time	container_minute_start_time	container_wait_time_unagg	cts.system	cts.date

===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		number_apps                 bigint,
		host                        string,
		requestedtime               bigint,
        allocatedtime               bigint,
		acquiredtime                bigint,
        runningtime                 bigint,
		requestedtime_minute        bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		cts.container_wait_time,
		cts.container_wait_time
		+floor(cf.requestedtime/1000)
		-cts.minute_start
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Thu Sep 10 16:43:18 UTC 2015
-------------------------------------------------------------------

cts.container_wait_time	cts.memory	cts.cluster_memory	cts.minute_start	cts.job_id	cts.queue	cts.container_id	cts.state	cts.measure_date	cts.account	cts.cluster_uuid	cts.principal_uuid	cts.user_key	vcores	cts.number_apps	cts.host	cf.requestedtime	cf.allocatedtime	cf.acquiredtime	cf.runningtime	requestedtime_minute	container_wait_time_unagg	cts.system	cts.date

===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		container_size              int,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		number_apps                 bigint,
		host                        string,
		requestedtime               bigint,
        allocatedtime               bigint,
		acquiredtime                bigint,
        runningtime                 bigint,
		requestedtime_minute        bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Wed Sep 16 20:27:36 UTC 2015
-------------------------------------------------------------------

_col0	_col1	_col2	_col3	_col4	_col5	_col6	_col7	_col8	_col9	_col10	_col11	_col12	_col13	_col14	_col15	_col16	_col17	_col18	_col19	_col20	_col21	_col22	_col23	_col24

===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		container_size              int,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		container_vcores            int,
		number_apps                 bigint,
		host                        string,
		requestedtime               bigint,
        allocatedtime               bigint,
		acquiredtime                bigint,
        runningtime                 bigint,
		requestedtime_minute        bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Wed Sep 16 20:42:04 UTC 2015
-------------------------------------------------------------------

_col0	_col1	_col2	_col3	_col4	_col5	_col6	_col7	_col8	_col9	_col10	_col11	_col12	_col13	_col14	_col15	_col16	_col17	_col18	_col19	_col20	_col21	_col22	_col23	_col24	_col25

===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		container_size              int,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		container_vcores            int,
		number_apps                 bigint,
		host                        string,
		requestedtime               bigint,
        allocatedtime               bigint,
		acquiredtime                bigint,
        runningtime                 bigint,
        reservedtime                bigint,
		requestedtime_minute        bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 06:12:24 UTC 2015
-------------------------------------------------------------------


===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		container_size              int,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		container_vcores            int,
		number_apps                 bigint,
		host                        string,
		requestedtime               bigint,
        allocatedtime               bigint,
		acquiredtime                bigint,
        runningtime                 bigint,
        reservedtime                bigint,
		requestedtime_minute        bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.containerid as container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.containerid = cf.containerid and
	cts.system 		 = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 06:15:11 UTC 2015
-------------------------------------------------------------------


===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		container_size              int,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		container_vcores            int,
		number_apps                 bigint,
		host                        string,
		requestedtime               bigint,
        allocatedtime               bigint,
		acquiredtime                bigint,
        runningtime                 bigint,
        reservedtime                bigint,
		requestedtime_minute        bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.containerid as container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.containerid = cf.containerid and
	cts.system 		= cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 06:16:23 UTC 2015
-------------------------------------------------------------------


===================================================================
USE eric_cluster_metrics_dev_4;

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time         bigint,
		memory                      double,
		container_size              int,
		cluster_memory              bigint,
		minute_start                int,
		job_id                      string,
		queue                       string,
		container_id                string,
		state                       string,
		measure_date                string,
		account                     int,
		cluster_uuid                string,
		principal_uuid              string,
		user_key                    string,
		vcores                      double,
		container_vcores            int,
		number_apps                 bigint,
		host                        string,
		requestedtime               bigint,
        allocatedtime               bigint,
		acquiredtime                bigint,
        runningtime                 bigint,
        reservedtime                bigint,
		requestedtime_minute        bigint,
		container_wait_time_unagg   bigint
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.containerid as container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.containerid = cf.containerid and
	cts.system 		= cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 16:12:15 UTC 2015
-------------------------------------------------------------------


===================================================================
USE eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
            end
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		= cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 18:19:05 UTC 2015
-------------------------------------------------------------------


===================================================================
USE eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
            end
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	container_time_series as cts,
	container_fact as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		= cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 18:39:04 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
            end
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		= cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 18:49:53 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
            end
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id = cf.containerid and
	cts.system 		= cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 18:50:33 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        --reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    --cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
            end
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:02:01 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double
		--container_size                      int,
		--cluster_memory                      bigint,
		--minute_start                        int,
		--job_id                              string,
		--queue                               string,
		--container_id                        string,
		--state                               string,
		--measure_date                        string,
		--account                             int,
		--cluster_uuid                        string,
		--principal_uuid                      string,
		--user_key                            string,
		--vcores                              double,
		--container_vcores                    int,
		--number_apps                         bigint,
		--host                                string,
		--requestedtime                       bigint,
        --allocatedtime                       bigint,
		--acquiredtime                        bigint,
        --runningtime                         bigint,
        --reservedtime                        bigint,
		--requestedtime_minute                bigint,
		--container_wait_time_unagg           bigint,
		--container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    --cf.memory as container_size,
	--cts.cluster_memory,
	--cts.minute_start,
	--cts.job_id
	--cts.queue,
	--cts.container_id,
	--cts.state,
	--cts.measure_date,
	--cts.account,
	--cts.cluster_uuid,
	--cts.principal_uuid,
	--cts.user_key,
	--cts.memory/cf.memory*cts.vcores as vcores,
	--cts.vcores as container_vcores,
	--cts.number_apps,
	--cts.host,
	--cf.requestedtime,
    --cf.allocatedtime,
	--cf.acquiredtime,
    --cf.runningtime,
    --cf.reservedtime,
	--floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	--if(cts.state='REQUESTED',
    --    if(floor(cf.requestedtime/60000)*60=cts.minute_start,
	--	    cts.container_wait_time,
	--	    cts.container_wait_time
	--	    +floor(cf.requestedtime/1000)
	--	    -cts.minute_start),
    --    0
	--) AS container_wait_time_unagg,
	--if(cts.state='REQUESTED',
    --    case
    --        when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            60
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            minute_start+60-cf.requestedtime/1000
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
    --            (cf.allocatedtime-cf.requestedtime)/1000
    --        else
    --            0
    --        end
	--) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:18:26 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint
		--requestedtime_minute                bigint,
		--container_wait_time_unagg           bigint,
		--container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	--floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	--if(cts.state='REQUESTED',
    --    if(floor(cf.requestedtime/60000)*60=cts.minute_start,
	--	    cts.container_wait_time,
	--	    cts.container_wait_time
	--	    +floor(cf.requestedtime/1000)
	--	    -cts.minute_start),
    --    0
	--) AS container_wait_time_unagg,
	--if(cts.state='REQUESTED',
    --    case
    --        when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            60
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            minute_start+60-cf.requestedtime/1000
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
    --            (cf.allocatedtime-cf.requestedtime)/1000
    --        else
    --            0
    --        end
	--) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:19:08 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string
		--requestedtime                       bigint,
        --allocatedtime                       bigint,
		--acquiredtime                        bigint,
        --runningtime                         bigint,
        --reservedtime                        bigint
		--requestedtime_minute                bigint,
		--container_wait_time_unagg           bigint,
		--container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	--cf.requestedtime,
    --cf.allocatedtime,
	--cf.acquiredtime,
    --cf.runningtime,
    --cf.reservedtime,
	--floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	--if(cts.state='REQUESTED',
    --    if(floor(cf.requestedtime/60000)*60=cts.minute_start,
	--	    cts.container_wait_time,
	--	    cts.container_wait_time
	--	    +floor(cf.requestedtime/1000)
	--	    -cts.minute_start),
    --    0
	--) AS container_wait_time_unagg,
	--if(cts.state='REQUESTED',
    --    case
    --        when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            60
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            minute_start+60-cf.requestedtime/1000
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
    --            (cf.allocatedtime-cf.requestedtime)/1000
    --        else
    --            0
    --        end
	--) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:19:42 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string
		--state                               string,
		--measure_date                        string,
		--account                             int,
		--cluster_uuid                        string,
		--principal_uuid                      string,
		--user_key                            string,
		--vcores                              double,
		--container_vcores                    int,
		--number_apps                         bigint,
		--host                                string,
		--requestedtime                       bigint,
        --allocatedtime                       bigint,
		--acquiredtime                        bigint,
        --runningtime                         bigint,
        --reservedtime                        bigint
		--requestedtime_minute                bigint,
		--container_wait_time_unagg           bigint,
		--container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id
	cts.queue,
	cts.container_id
	--cts.state,
	--cts.measure_date,
	--cts.account,
	--cts.cluster_uuid,
	--cts.principal_uuid,
	--cts.user_key,
	--cts.memory/cf.memory*cts.vcores as vcores,
	--cts.vcores as container_vcores,
	--cts.number_apps,
	--cts.host,
	--cf.requestedtime,
    --cf.allocatedtime,
	--cf.acquiredtime,
    --cf.runningtime,
    --cf.reservedtime,
	--floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	--if(cts.state='REQUESTED',
    --    if(floor(cf.requestedtime/60000)*60=cts.minute_start,
	--	    cts.container_wait_time,
	--	    cts.container_wait_time
	--	    +floor(cf.requestedtime/1000)
	--	    -cts.minute_start),
    --    0
	--) AS container_wait_time_unagg,
	--if(cts.state='REQUESTED',
    --    case
    --        when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            60
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            minute_start+60-cf.requestedtime/1000
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
    --            (cf.allocatedtime-cf.requestedtime)/1000
    --        else
    --            0
    --        end
	--) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:20:30 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string
		--state                               string,
		--measure_date                        string,
		--account                             int,
		--cluster_uuid                        string,
		--principal_uuid                      string,
		--user_key                            string,
		--vcores                              double,
		--container_vcores                    int,
		--number_apps                         bigint,
		--host                                string,
		--requestedtime                       bigint,
        --allocatedtime                       bigint,
		--acquiredtime                        bigint,
        --runningtime                         bigint,
        --reservedtime                        bigint
		--requestedtime_minute                bigint,
		--container_wait_time_unagg           bigint,
		--container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	--cts.state,
	--cts.measure_date,
	--cts.account,
	--cts.cluster_uuid,
	--cts.principal_uuid,
	--cts.user_key,
	--cts.memory/cf.memory*cts.vcores as vcores,
	--cts.vcores as container_vcores,
	--cts.number_apps,
	--cts.host,
	--cf.requestedtime,
    --cf.allocatedtime,
	--cf.acquiredtime,
    --cf.runningtime,
    --cf.reservedtime,
	--floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	--if(cts.state='REQUESTED',
    --    if(floor(cf.requestedtime/60000)*60=cts.minute_start,
	--	    cts.container_wait_time,
	--	    cts.container_wait_time
	--	    +floor(cf.requestedtime/1000)
	--	    -cts.minute_start),
    --    0
	--) AS container_wait_time_unagg,
	--if(cts.state='REQUESTED',
    --    case
    --        when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            60
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
    --            minute_start+60-cf.requestedtime/1000
    --        when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
    --            (cf.allocatedtime-cf.requestedtime)/1000
    --        else
    --            0
    --        end
	--) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:21:08 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
            end
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:21:39 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
            end,
        0
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:22:34 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
        end,
        0
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:33:56 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
        end,
        0
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:35:18 UTC 2015
-------------------------------------------------------------------


===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
        end,
        0
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 19:35:33 UTC 2015
-------------------------------------------------------------------

_col0	_col1	_col2	_col3	_col4	_col5	_col6	_col7	_col8	_col9	_col10	_col11	_col12	_col13	_col14	_col15	_col16	_col17	_col18	_col19	_col20	_col21	_col22	_col23	_col24	_col25	_col26	_col27

===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 <  minute_start+60) then
                cf.allocatedtime/1000-minute_start
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
        end,
        0
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Fri Sep 25 20:13:05 UTC 2015
-------------------------------------------------------------------

_col0	_col1	_col2	_col3	_col4	_col5	_col6	_col7	_col8	_col9	_col10	_col11	_col12	_col13	_col14	_col15	_col16	_col17	_col18	_col19	_col20	_col21	_col22	_col23	_col24	_col25	_col26	_col27

===================================================================
set SERIES_TABLE=eric_cluster_metrics_dev_4.container_time_series;
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use eric_cluster_metrics_dev_4;

-- Changes to container_time_series
-- Vcore-smoothed
-- regular vcore kept
-- waitingtime unaggregated (floating point)
-- Column for minute when container was first requested

-- Need container_time_series with ALL the containers

drop table if exists container_time_series_alloc_and_run_extend;

create table
    container_time_series_alloc_and_run_extend (
		container_wait_time                 bigint,
		memory                              double,
		container_size                      int,
		cluster_memory                      bigint,
		minute_start                        int,
		job_id                              string,
		queue                               string,
		container_id                        string,
		state                               string,
		measure_date                        string,
		account                             int,
		cluster_uuid                        string,
		principal_uuid                      string,
		user_key                            string,
		vcores                              double,
		container_vcores                    int,
		number_apps                         bigint,
		host                                string,
		requestedtime                       bigint,
        allocatedtime                       bigint,
		acquiredtime                        bigint,
        runningtime                         bigint,
        reservedtime                        bigint,
		requestedtime_minute                bigint,
		container_wait_time_unagg           bigint,
		container_wait_time_unagg_exact     double
	)
partitioned by (
	system string,
	date string
	)
stored as
	orc;

SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

insert overwrite table container_time_series_alloc_and_run_extend
partition(system,date)
SELECT
	cts.container_wait_time,
	cts.memory,
    cf.memory as container_size,
	cts.cluster_memory,
	cts.minute_start,
	cts.job_id,
	cts.queue,
	cts.container_id,
	cts.state,
	cts.measure_date,
	cts.account,
	cts.cluster_uuid,
	cts.principal_uuid,
	cts.user_key,
	cts.memory/cf.memory*cts.vcores as vcores,
	cts.vcores as container_vcores,
	cts.number_apps,
	cts.host,
	cf.requestedtime,
    cf.allocatedtime,
	cf.acquiredtime,
    cf.runningtime,
    cf.reservedtime,
	floor(cf.requestedtime/60000)*60 as requestedtime_minute,
	if(cts.state='REQUESTED',
        if(floor(cf.requestedtime/60000)*60=cts.minute_start,
		    cts.container_wait_time,
		    cts.container_wait_time
		    +floor(cf.requestedtime/1000)
		    -cts.minute_start),
        0
	) AS container_wait_time_unagg,
	if(cts.state='REQUESTED',
        case
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                60
            when (cf.requestedtime/1000 <= minute_start and cf.allocatedtime/1000 <  minute_start+60) then
                cf.allocatedtime/1000-minute_start
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 >= minute_start+60) then
                minute_start+60-cf.requestedtime/1000
            when (cf.requestedtime/1000 >  minute_start and cf.allocatedtime/1000 <  minute_start+60 and cf.allocatedtime/1000>0) then
                (cf.allocatedtime-cf.requestedtime)/1000
            else
                0
        end,
        0
	) AS container_wait_time_unagg_exact,
	cts.system,
	cts.date
FROM
	${hiveconf:SERIES_TABLE} as cts,
	${hiveconf:FACT_TABLE} as cf
WHERE
	cts.container_id    = cf.containerid and
	cts.system          = cf.system


-------------------------------------------------------------------
Starting query at: Sat Sep 26 00:58:43 UTC 2015
-------------------------------------------------------------------

_col0	_col1	_col2	_col3	_col4	_col5	_col6	_col7	_col8	_col9	_col10	_col11	_col12	_col13	_col14	_col15	_col16	_col17	_col18	_col19	_col20	_col21	_col22	_col23	_col24	_col25	_col26	_col27

