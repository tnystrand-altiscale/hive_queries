+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DAT DUMP FOR: initial_spark_compare.sql
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===================================================================

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jw.memory_waiting,
    jw.max_mem_capacity_robbed_mbsec,
    jw.elastic_unfairness_mem_capped_mbsec,
    jw.competing_job_mem_capped_mbsec
from
    job_categories_from_spark as jc,
    job_wait_reasons_sec_granularity as jw
-------------------------------------------------------------------
Starting query at: Thu Sep 17 06:43:50 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jw.memory_waiting,
    jw.max_mem_capacity_robbed_mbsec,
    jw.elastic_unfairness_mem_capped_mbsec,
    jw.competing_job_mem_capped_mbsec
from
    job_categories_from_spark as jc,
    job_wait_reasons_sec_granularity as jw
where
    jc.job_id=jw.job_id
-------------------------------------------------------------------
Starting query at: Thu Sep 17 06:44:55 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.total_memory_delayed	jw.memory_waiting	jw.max_mem_capacity_robbed_mbsec	jw.elastic_unfairness_mem_capped_mbsec	jw.competing_job_mem_capped_mbsec

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting,
    jwn.memory_waiting,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbsec,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbsec,
    jws.competing_job_mem_capped_mbsec
    jwn.competing_job_mem_capped_mbsec
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Fri Sep 18 05:38:48 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting,
    jwn.memory_waiting,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbsec,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbsec,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbsec
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Fri Sep 18 05:40:02 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting,
    jwn.memory_waiting,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbsmin
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Fri Sep 18 05:41:26 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting,
    jwn.memory_waiting,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbsmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Fri Sep 18 05:42:15 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting,
    jwn.memory_waiting,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Fri Sep 18 05:42:39 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Fri Sep 18 05:44:47 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Mon Sep 21 02:07:57 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Mon Sep 21 05:18:19 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Mon Sep 21 22:34:07 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Mon Sep 21 23:03:08 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Tue Sep 22 00:51:13 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Tue Sep 22 05:36:26 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Tue Sep 22 07:25:43 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin

===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_mbsec,
    jwn.max_vcr_capacity_robbed_mbmin,
    jws.elastic_unfairness_vcr_capped_mbsec,
    jwn.elastic_unfairness_vcr_capped_mbmin,
    jws.competing_job_vcr_capped_mbsec,
    jwn.competing_job_vcr_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Wed Sep 23 15:40:42 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_mbsec,
    jwn.max_vcr_capacity_robbed_mbmin,
    jws.elastic_unfairness_vcr_capped_mbsec,
    jwn.elastic_unfairness_vcr_capped_mbmin,
    jws.competing_job_vcr_capped_mbsec,
    jwn.competing_job_vcr_capped_mbmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Wed Sep 23 16:01:10 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcore_capacity_robbed_vcrsec,
    jwn.max_vcore_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Wed Sep 23 16:05:29 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcore_capacity_robbed_vcrsec,
    jwn.max_vcore_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Wed Sep 23 16:06:15 UTC 2015
-------------------------------------------------------------------


===================================================================
use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as select
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    jwn.memory_waiting as memory_waiting_min,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
    
-------------------------------------------------------------------
Starting query at: Wed Sep 23 16:08:09 UTC 2015
-------------------------------------------------------------------

jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	memory_waiting_min	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        job_id,
        system,
        min(measure_date) as measure_date,
        min(requestedtime) as launch_time,
        sum(if (allcoatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        measure_date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        job_id,
        system
    )
select
    ew.launchtime,
    ew.measure_date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait as ew
on
    jwn.job_id=ew.job_id

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:40:35 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        job_id,
        system,
        min(measure_date) as measure_date,
        min(requestedtime) as launch_time,
        sum(if (allcoatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        measure_date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        job_id,
        system
    )
select
    ew.launchtime,
    ew.measure_date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.job_id

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:41:49 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(measure_date) as measure_date,
        min(requestedtime) as launch_time,
        sum(if (allcoatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        measure_date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        job_id,
        system
    )
select
    ew.launchtime,
    ew.measure_date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:42:25 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launch_time,
        sum(if (allcoatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        measure_date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        job_id,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:43:14 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launch_time,
        sum(if (allcoatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        job_id,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:43:40 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launch_time,
        sum(if (allcoatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        job_id,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.jobid=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:44:05 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launch_time,
        sum(if (allcoatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:44:50 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launch_time,
        sum(if (allocatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:48:02 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(if (allocatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jws.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:48:22 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(if (allocatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:48:48 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(if (allocatedtime>0 and requestedtime>0,(allocatedtime-requestedtime)/1000*memory,0)) as total_waittime_exact
    from
        cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 03:59:15 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0)
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
            ) as total_waittime_exact
    from
        eric_cluster_metrics_prod_1.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    --jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_converted,
    --jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    --jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    --jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    --jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    --jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
--join
--    job_wait_reasons_sec_granularity as jws
--on
--    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jc.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 18:10:45 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0)
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    --jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_converted,
    --jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    --jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    --jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    --jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    --jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
--join
--    job_wait_reasons_sec_granularity as jws
--on
--    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jc.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 18:11:36 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    --jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_converted,
    --jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    --jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    --jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    --jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    --jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
--join
--    job_wait_reasons_sec_granularity as jws
--on
--    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jc.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 18:12:05 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    --jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_converted,
    --jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    --jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    --jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    --jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    --jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
--join
--    job_wait_reasons_sec_granularity as jws
--on
--    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jc.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 18:12:56 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    --jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_converted,
    --jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    --jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    --jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    --jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    --jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
--join
--    job_wait_reasons_sec_granularity as jws
--on
--    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jc.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 18:19:51 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_converted,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 18:21:42 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 18:22:49 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 19:51:58 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 20:05:02 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 20:12:06 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 20:22:40 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 20:34:02 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_cluster_metrics_dev_4.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 21:50:29 UTC 2015
-------------------------------------------------------------------


===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_backup.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Thu Sep 24 21:54:18 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_backup.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Fri Sep 25 05:41:18 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        eric_backup.container_fact
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Fri Sep 25 20:18:46 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Fri Sep 25 20:34:34 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Sat Sep 26 01:14:43 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Sat Sep 26 01:37:41 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(requestedtime>0) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Mon Sep 28 17:47:00 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.max_capacity_memory_delayed	jc.user_limit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(if(requestedtime>0,requestedtime,reservedtime)) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Mon Sep 28 18:14:08 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.single_job_max_capacity_memory_delayed	jc.multiplejob_max_capacity_memory_delayed	jc.userlimit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.singlejob_max_capacity_vcores_delayed	jc.multijob_max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(if(requestedtime>0,requestedtime,reservedtime)) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
join
    job_wait_reasons_sec_granularity as jws
on
    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jws.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Tue Sep 29 18:11:03 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.singlejob_max_capacity_memory_delayed	jc.multijob_max_capacity_memory_delayed	jc.userlimit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.singlejob_max_capacity_vcores_delayed	jc.multijob_max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	memory_waiting_sec	ew.total_waittime_exact	jws.max_mem_capacity_robbed_mbsec	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jws.elastic_unfairness_mem_capped_mbsec	jwn.elastic_unfairness_mem_capped_mbmin	jws.competing_job_mem_capped_mbsec	jwn.competing_job_mem_capped_mbmin	jws.max_vcr_capacity_robbed_vcrsec	jwn.max_vcr_capacity_robbed_vcrmin	jws.elastic_unfairness_vcore_capped_vcrsec	jwn.elastic_unfairness_vcore_capped_vcrmin	jws.competing_job_vcore_capped_vcrsec	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(if(requestedtime>0,requestedtime,reservedtime)) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    --jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    --jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    --jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    --jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    --jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    --jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    --jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
--join
--    job_wait_reasons_sec_granularity as jws
--on
--    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jc.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Tue Sep 29 21:43:04 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.singlejob_max_capacity_memory_delayed	jc.multijob_max_capacity_memory_delayed	jc.userlimit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.singlejob_max_capacity_vcores_delayed	jc.multijob_max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	ew.total_waittime_exact	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jwn.elastic_unfairness_mem_capped_mbmin	jwn.competing_job_mem_capped_mbmin	jwn.max_vcr_capacity_robbed_vcrmin	jwn.elastic_unfairness_vcore_capped_vcrmin	jwn.competing_job_vcore_capped_vcrmin

===================================================================
set START_DATE='2015-07-08';
set END_DATE='2015-07-14';
set FACT_TABLE=eric_cluster_metrics_dev_4.container_fact;

use thomas_test;

drop table if exists initial_spark_compare;

create table initial_spark_compare
as with exact_wait_time as (
    select
        jobid,
        system,
        min(date) as date,
        min(if(requestedtime>0,requestedtime,reservedtime)) as launchtime,
        sum(
            case
                when (allocatedtime>0 and requestedtime>0) then
                    (allocatedtime-requestedtime)/1000*memory
                else
                    0
                end
            ) as total_waittime_exact
    from
        ${hiveconf:FACT_TABLE}
    where
        date between ${hiveconf:START_DATE} and ${hiveconf:END_DATE}
    group by
        jobid,
        system
    )
select
    ew.launchtime,
    ew.date,
    jc.*, 
    --jws.memory_waiting as memory_waiting_sec,
    ew.total_waittime_exact,
    --jws.max_mem_capacity_robbed_mbsec,
    jwn.max_mem_capacity_robbed_mbmin,
    jwn.memory_sec_convrt,
    --jws.elastic_unfairness_mem_capped_mbsec,
    jwn.elastic_unfairness_mem_capped_mbmin,
    --jws.competing_job_mem_capped_mbsec,
    jwn.competing_job_mem_capped_mbmin,
    --jws.max_vcr_capacity_robbed_vcrsec,
    jwn.max_vcr_capacity_robbed_vcrmin,
    --jws.elastic_unfairness_vcore_capped_vcrsec,
    jwn.elastic_unfairness_vcore_capped_vcrmin,
    --jws.competing_job_vcore_capped_vcrsec,
    jwn.competing_job_vcore_capped_vcrmin
from
    job_categories_from_spark as jc
--join
--    job_wait_reasons_sec_granularity as jws
--on
--    jc.job_id=jws.job_id
join
    job_wait_reasons_min_granularity as jwn
on
    jc.job_id=jwn.job_id
join
    exact_wait_time as ew
on
    jwn.job_id=ew.jobid

-------------------------------------------------------------------
Starting query at: Tue Sep 29 21:56:47 UTC 2015
-------------------------------------------------------------------

ew.launchtime	ew.date	jc.job_id	jc.system	jc.singlejob_max_capacity_memory_delayed	jc.multijob_max_capacity_memory_delayed	jc.userlimit_memory_delayed	jc.elastic_unfariness_memory_delayed	jc.competing_jobs_memory_delayed	jc.singlejob_max_capacity_vcores_delayed	jc.multijob_max_capacity_vcores_delayed	jc.user_limit_vcores_delayed	jc.elastic_unfariness_vcores_delayed	jc.competing_jobs_vcores_delayed	jc.total_memory_delayed	ew.total_waittime_exact	jwn.max_mem_capacity_robbed_mbmin	jwn.memory_sec_convrt	jwn.elastic_unfairness_mem_capped_mbmin	jwn.competing_job_mem_capped_mbmin	jwn.max_vcr_capacity_robbed_vcrmin	jwn.elastic_unfairness_vcore_capped_vcrmin	jwn.competing_job_vcore_capped_vcrmin

